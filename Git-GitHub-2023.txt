
+++Proyecto de estudio de Git y GitHub 2023+++

1º Instalar Git y configurar las variables globales:
$ git config --global user.name "NombreUsuario"
$ git config --global user.email "mi.email@gmail.com"

2º Crear un directorio 
$ mkdir Git-GitHub-2023

3º Inicializando un repositorio en un directorio existente
$ cd Git-GitHub-2023
$ git init

Nota: Si llama a la rama como: master
se puede cambiar el nombre a la rama creada como:
$git branch -m main (en lugar de master)

También nos permite que se inicialice por defecto el nombre
de todas las ramas para los proyectos nuevos:
Utilizando:
git config --global init.defaultBranch <name>

Repaso comandos:
$ git status
$ git add helloWorld.txt
$ git add .
$ git commit -m "Este es mi primer commit"
$ git checkout helloWorld.txt -> Recuperar el contenido del último commit del fichero y descartar los cambios.
$ git reset -> Descartar todos los cambios actuales y restaurar al estado del último commit

$ git log -> Listado de Commits
$ git log --graph
$ git log --graph --pretty=oneline
$ git log --graph --decorate --all --oneline

#Alias
$ git config --global alias.tree = "log --graph --decorate --all --oneline" -> crear alias : tree
$ git tree -> ejecutar alias tree (ejecuta: git log --graph --decorate --all --oneline)

#git ignore
$ touch .gitignore

Nota: Añadir al fichero .gitignore
**/DS_Store

$ git add. .gitignore
$ git commit -m "Se añade el .gitignore"
$ git status

git diff -> Resumen de cambios efectuados en los ficheros antes de hacer commit

git checkout <hash> -> Navegar a un punto del control de versiones
git checkout HEAD

#Makigas...

#Nota: *Si se nos ha olvidado meter algún cambio en el último commit
git add index.html
git commit --amend -> El último commit ahora incluye también los nuevos cambios en staging area

#Deshacer cambios:

EJEMPLO1 : git checkout -- <file>... -> Para descartar los cambios en el directorio de trabajo
1º Ejemplo: borrar texto en un archivo que está en el repositorio
2º Por tanto está modificado en el directorio de trabajo
3º Ejecutar $ git checkout -- index.html -> Para descartar cambios en el directorio de trabajo

EJEMPLO2 : git reset HEAD <file> -> Para descartar los cambios de staging area (to unstage)
1º Ejemplo: borrar texto en un archivo que está en el repositorio
2º Por tanto está modificado en el directorio de trabajo
3º Ejecutar $ git add .
4º Ejecutar $ git reset HEAD index.html -> Para descartar los cambios de staging area (to unstage)
5º Ahora la modificación está en mi directorio de trabajo
6º Ejecutar $ git checkout -- index.html -> Para descartar cambios en el directorio de trabajo

#Deshacer contenido de un commit [reset|revert]
#Ojo que el comando: git reset -> es un cambio destructivo

EJEMPLO: git reset
1º git log --oneline -> Para visualizar el listado de commit y buscar el hash de commit al que queremos volver
2º Alguien en un commit ha borrado el texto de un fichero
3º git reset f5f0388  -> Elimina los commits futuros para volver al hash seleccionado
4º git status -> Se muestra el fichero como modificado: 'modified: index.html' en mi directorio de trabajo
porque el contenido del fichero de mi directorio de trabajo contiene aún el fichero con el texto borrado
para actualizar el texto borrado del repositorio en mi fichero del mi directorio de trabajo
5º git checkout -- index.html

EJEMPLO: git reset --hard <hash>
1º Alguien en un commit ha borrado el texto de un fichero
2º git reset --hard f5f0388  -> Elimina los commits futuros para volver al hash seleccionado
3º git status -> Todo ok
se ha sobreescrito el contenido del fichero del commit seleccionado también en mi directorio de trabajo y en el staging area

EJEMPLO: git reset --soft <hash>
1º Alguien en un commit ha borrado el texto de un fichero
2º git reset --soft f5f0388  -> Elimina los commits futuros para volver al hash seleccionado
3º git status -> Se muestra el fichero como modificado: 'modified: index.html' en el staging area
se ha sobreescrito el contenido del fichero del commit seleccionado en mi directorio de trabajo y está pendiente en el staging area

#Sintaxis HEAD
Puntero al Commit que tenemos en revisión

$ git log --oneline --decorate (el flag --decorate -> Visualiza los punteros de nuestro repositorio como (HEAD -> master)
b4844be (HEAD -> master) Embellece el sitio web
f5f0388 Indica que el sitio web está a punto de ser inaugurado
ab18c91 Nueva plantilla de la página web
...		...

Podemos utilizar la en la sintaxis el nombre del puntero HEAD
Por ejemplo: HEAD~1 -> Un commit antes de HEAD 
Por ejemplo: HEAD~2 -> Dos commits antes de HEAD

git diff HEAD~1 HEAD -> Compara el último commit HEAD, con su anterior

#git revert 

EJEMPLO: git revert (para deshacer un commit)
Para deshacer un commit:
b4844be (HEAD -> master) Embellece el sitio web
f5f0388 Indica que el sitio web está a punto de ser inaugurado
ab18c91 Nueva plantilla de la página web

git revert b4844be (O también git revert HEAD) -> Se deshace el cambio revirtiendo las líneas del cambio mostradas en diff
Ahora hacemos un commit para reflejar el cambio:
1234567 Revert "Embellece el sitio web"


EJEMPLO: git revert (para deshacer dos commits)
Para deshacer dos commits:
7d0829a (HEAD -> master) Blink, blink, blink
b4844be Embellece el sitio web
f5f0388 Indica que el sitio web está a punto de ser inaugurado
ab18c91 Nueva plantilla de la página web

#Una opción es replicar el procedimiento anterior:
git revert 7d0829a
git revert b4844be
# ...pero entonces tendremos dos commits para revertir la situación
# y desearíamos evitar esto
d1f5d0a (HEAD -> master) Revert "Blink, blink, blink"
6e060c0 Revert "Embellece el sitio web"
7d0829a Blink, blink, blink
b4844be Embellece el sitio web

#Otra opción
git revert --no-commit HEAD   -> Deshace el primer commit: HEAD, deja los cambios en staging area y no pide commit
git revert --no-commit HEAD~1 -> Deshace el segundo commit: HEAD~1, deja los cambios en staging area y no pide commit
# y ahora:
# (all conflicts fixed: run "git revert --continue")
# (use "git revert --abort" to cancel the revert operation)
# Ejecutamos
git revert --continue -> Nos pide comentario para el commit y se crea un único commit
433f33d (HEAD -> master) Revert "Embellece el sitio web"
7d0829a Blink, blink, blink
b4844be Embellece el sitio web

#Ramas
$ git branch
* main (old master) -> Rama activa y única rama actualmente

$ git branch feature-newstyle -> Crea una nueva rama
$ git branch 
  feature-newstyle -> Rama creada
  * main -> Rama activa

#Cambiar de rama
$ git checkout feature-newstyle

#Crear una nueva rama y cambiarse a ella
$ git checkout -b feature-newhomepage

#Cambiar/Renombrar el nombre de una rama
git branch -m feature-newhomepage feature-newhome

#Borrar una rama
git branch -d testing

#Commits (18/01/2023)

git log --oneline --decorate --all
git log --oneline --decorate --all --graph

#Fusiones-Merges: merge

1º Partimos de:

* 4c794ae (HEAD -> fix-fecha) Retrasar la apertura de la web
* 433f33d (master) Revert "Embellece el sitio web"
* 7d0829a Blink, Blink, Blink

2º Queremos fusionar el commit 4c794ae, de la rama: fix-fecha con la rama master

3º Ir a rama destino:
$ git checkout master

2º Indicar rama origen:
$ git merge fix-fecha

Por defecto, se utiliza la estrategia de Fast-forward
*Tienes que hacer una fusión entre una rama que tiene modificaciones: fix-fecha
y otra rama que no tiene modificaciones: master

Para solucionar esta fusión, con  la estrategia Fast-forward
Git mueve el puntero de la rama master apuntando al HEAD
de esta forma la rama master ya tiene todos los commits anteriores más el nuevo fusionado.

* 4c794ae (HEAD -> master, fix-fecha) Retrasar la apertura de la web
* 433f33d Revert "Embellece el sitio web"
* 7d0829a Blink, Blink, Blink


*Estrategia de fusión recursiva

* 4c794ae (HEAD -> master, fix-fecha) Retrasar la apertura de la web
 * 214960d (feature-newstyle) Retoca el estilo de la página
* 433f33d Revert "Embellece el sitio web"

se utiliza cuando queremos fusionar cambios en dos ramas en las que ambas tienen cambios
* 4c794ae (HEAD -> master) y * 214960d (feature-newstyle) 

Nosotros tenemos que juntar cambios hechos en una rama con cambios hechos en la otra rama
para ello crearemos un tercer commit
en el que se integren los cambios hechos en ambas ramas
En ambas ramas se han añadido y eliminado filas
y Git intentará apliacar los cambios de la rama origen sobre la rama destino
y si Git lo consigue automáticamente, se completará guardando el nuevo commit con los cambios.
*Merge made by the 'recursive' stratagy

* 1b660bf (HEAD -> master) Merge branch 'feature-newstyle'
 * 214960d (feature-newstyle) Retoca el estilo de la página
* 4c794ae (fix-fecha) Retrasar la apertura de la web
* 433f33d Revert "Embellece el sitio web"

#Alias
Se guardan en la configuración de Git

#Comando que queremos asignar a un alias
$ git log --oneline --decorate --all --graph

#Crear alias asignando a 'alias.lodag' el comando anterior
$ git config --global alias.lodag 'log --oneline --decorate --all --graph'

#Ejecutar el alias
$ git lodag
* 02e0665 (HEAD -> main, mejora-descripcion-proyecto) Mejora descripción proyecto
* 38d25a1 Creación del proyecto

#Si lo necesitamos se le pueden añadir más parámetros extras
$ git lodag --graph --all

#Otro ejemplo
#Para eliminar un archivo del staging area, utilizamos la sintaxis: 
use "git reset HEAD <file>..." to unstage

#Crear alias asignando a 'alias.unstage' el comando anterior
$ git config --global alias.unstage 'reset HEAD --'

#Para hacer el unstage de un fichero index.html de un fichero que hemos subido por error al unstage.
git unstage index.html

#Para ver todos los alias
git config --global --get-regexp alias

#Para borrar un alias
git config --global --unset alias.lodag


#Resolver Conflictos ******************************************
***************************************************************
*************************************************************** .INICIO

#Se ha producido un conflicto al intentar fusionar dos ramas: main y mejora-descripcion-proyecto

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main)
$ git merge mejora-descripcion-proyecto
Auto-merging README.txt
CONFLICT (content): Merge conflict in README.txt
Automatic merge failed; fix conflicts and then commit the result.

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)
$

#Para resolver el conflicto, abrimos el fichero donde Git ha detectado el conflicto
#Nos encontraremos:

<p>Prueba proyecto README!</p>

<p>Proyecto de propósito educacional.</p>

<<<<<<< HEAD
        <p>Período 2023/2024</p>
=======
        <p>Año actual 2023</p>
>>>>>>> mejora-descripcion-proyecto

#En el detalle del conflicto que inicia por: 
<<<<<<< + Commit vigente HEAD en la Rama destino main
#Seguido del texto del fichero en la Rama destino main
<p>Período 2023/2024</p>

#Una separación para el conflicto, que representa:
=======

#En el detalle del conflicto que continúa por
el texto del fichero de la rama origen
<p>Año actual 2023</p>
# Y Finaliza con 
>>>>>>> mejora-descripcion-proyecto (Siendo mejora-descripcion-proyecto la rama origen)

#PARA RESOLVER EL Conflictos
Corregir manualmente el conflicto y dejar el código generado por Git
el contenido que se espera que sea el definitivo.

#**************************************************************************
#Una vez resolvemos el conflicto Git nos indica las opciones: 

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)
$ git status
On branch main
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   README.txt

no changes added to commit (use "git add" and/or "git commit -a")

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)

#Ejecutamos $ git add .

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)
$ git add .

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)
$ git status
On branch main
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:
        modified:   README.txt

#Y Ahora finalizamos con el commit correspondiente

Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main|MERGING)
$ git commit -m "Conflicto resuelto"
[main 5dfffc1] Conflicto resuelto

#Todo OK

*   5dfffc1 (HEAD -> main) Conflicto resuelto
|\
| * bb9f6b7 (mejora-descripcion-proyecto) Año actual 2023
* | dcc7530 (fix-anio-vigente) Perído 2023/2024
* | a385e3d Actualizado Año actual 2023
|/
* 02e0665 Mejora descripción proyecto
* 38d25a1 Creación del proyecto

#Resolver Conflictos ******************************************
***************************************************************
*************************************************************** .FIN

#Tags/Etiquetas (LIGEROS) *************************************
***************************************************************
*************************************************************** .INICIO

Los Tags sirven para identificar Commits particulares
y que nos permita identificarlo mediante algún tipo de alias
Un Commit que deseamos que pueda perdurar para utilizar como referencia
o nos sirva para que nos permita volver facilmente.

Crearemos un Tag, y se va a generar un alias asociado a ese Commit en particular

El uso más normal de los Tags el etiquetar versiones de los proyectos

#Creamos un Tag sobre la rama main
$ git tag v0.2.0

#Sobre el Commit HEAD, el último de mi repositorio, queda indicado el Tag creado
Renegade@MiPC MINGW64 /c/proyectos/GitGitHub2023 (main)
$ git lodag
*   5dfffc1 (HEAD -> main, tag: v0.2.0) Conflicto resuelto
|\
| * bb9f6b7 (mejora-descripcion-proyecto) Año actual 2023
* | dcc7530 (fix-anio-vigente) Perído 2023/2024
* | a385e3d Actualizado Año actual 2023
|/
* 02e0665 Mejora descripción proyecto
* 38d25a1 Creación del proyecto

#Creamos un nuevo Tag para un commit concreto, por ejemplo:
$ git tag v0.1.0 02e0665

#Sobre el Commit indicado 02e0665, queda indicado el Tag creado
* 02e0665 (tag: v0.1.0) Mejora descripción proyecto
* 38d25a1 Creación del proyecto

#Ahora utilizamos el Tag creado para hacer un checkout, en lugar de indicar el hash del commit
$ git tag v.0.1.0

#Visualizar un listado de Tags
$ git tag
v0.1.0
v0.2.0

#Ayuda de las opciones del comando
$ git tag -h

#Tags/Etiquetas (LIGEROS) *************************************
***************************************************************
*************************************************************** .FIN

#Tags/Etiquetas (ANOTADOS) ************************************
***************************************************************
*************************************************************** .INICIO

Los Tags Anotados son punteros + información

Filtros de tags:
$ git tag -l
v0.1.0
v0.2.0

$ git tag -l "v0.1.*"
v0.1.0

$ git tag -l "v0.*.0"
v0.1.0
v0.2.0

#Borramos los tags ligeros que tenemos:
$ git tag -d v0.1.0 >> Deleted tag 'v0.1.0' (was 02e0665)
$ git tag -d v0.2.0 >> Deleted tag 'v0.2.0' (was 5dfffc1)

#Creamos un tag anotado (-a)
$ git tag -a v.1.0 >> Nos pedirá un mensaje para el Tag

Ejemplo:
Primera versión del sitio web.
*Los cambios que introducen esta versión son: xxxxxxxxxxxxxxxxxx
*Los bugs que arreglan esta versión son: xxxxxxxxxxxxxxx

$ git log...
*   5dfffc1 (HEAD, tag: v0.1.0, main) Conflicto resuelto

#Para ver los detalles de nuestro Tag anotada
$ git show v0.1.0

#También podemos utilizar el subcomando: show para ver detalles de main

$ git show main

commit 5dfffc11cc5b715b848b1d3f3ced968a98f611f6 (HEAD, tag: v0.1.0, main)
Merge: dcc7530 bb9f6b7
Author: XXXXXX <xxxxxx.xxxxxx@gmail.com>
Date:   Thu Jan 19 00:33:54 2023 +0100
... ...

#También podemos utilizar el subcomando: show para ver detalles de commit

$ git show 5dfffc11cc5b715b848b1d3f3ced968a98f611f6

Commit 5dfffc11cc5b715b848b1d3f3ced968a98f611f6 (HEAD, tag: v0.1.0, main)
Merge: dcc7530 bb9f6b7
Author: XXXXXX <xxxxxx.xxxxxx@gmail.com>
Date:   Thu Jan 19 00:33:54 2023 +0100


################################################################

#Stash ¿Cómo esconder cambios en Git?
#Hemos hecho cambios en nuestro proyecto y los hemos añadido en el staging area
#necesitamos cambiar de rama pero no queremos/podemos hacer un commit con los cambios
#y al mismo tiempo no queremos perder los cambios.
#utilizamos el stash para guardar los cambios en el repositorio pero que no se vean

$ git status
Changes to be committed:
	modified:   README.txt

#Utilizamos el stash para guardar los cambios
$ git stash
Saved working directory and index state WIP on (no branch): 5dfffc1 Conflicto resuelto

#Ahora han dejado de visializarse los cambios pendientes
$ git status
nothing to commit, working tree clean

#Para visualizar los elementos de la lista que tengo guardados en el stash:
$ git stash list
stash@{0}: WIP on (no branch): 5dfffc1 Conflicto resuelto

#Para recuperar y aplicar los últimos cambios 
#que tengo guardados en el stash en mi directorio de trabajo
$ git stash apply
Changes not staged for commit:
	modified:   README.txt
	
#Para visualizar los elementos de la lista que tengo guardados en el stash:
$ git stash list
stash@{0}: WIP on (no branch): 5dfffc1 Conflicto resuelto

#Para eliminar el primer elemento de la lista que tengo guardado en el stash:
$ git stash drop
Dropped refs/stash@{0} (5b22790c1a517969c99d54620ee29ea7e48f3dfb)

#Otro comando para guardar en el stash, personalizando con un comentario
$ git stash save "He modificado el archivo README.txt"
Saved working directory and index state On (no branch): He modificado el archivo README.txt

#Ahora se visializa con el comentario
$ git stash list
stash@{0}: On (no branch): He modificado el archivo README.txt

#Se puede obtener más información de un stash con
$ git stash show stash@{0}
 README.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

#Para aplicar al mismo tiempo el apply y el drop
#es decir, aplicar y sacar de la pila utilizamos
$ git stash pop
Changes not staged for commit:
	modified:   README.txt

Dropped refs/stash@{0} (404389dcf984bf79dc9d6d146f24aae82fca283c)


################################################################

#Remotos 2023

#Actualmente para utilizar un remoto ya no se utiliza usuario/contraseña para iniciar una sesión
#sino que se utiliza un token. Esto es así desde el 13 de agosto de 2021.

#1º Vamos a generar un Token desde mi cuenta de GitHub
#2º Ir a: Settings -> Developer Settings -> Personal Access Tokens
#3º Generate new token > Introducir un nombre para el Token
#4º Seleccionar un Expiration para el Token
#5º En la sección de Select scopes seleccionar el check 'repo' si corresponde
#6º Hacer clic en el botón 'Generate token'
#7º Guardar el token generado porque no podrá ser visualizado nunca más.

#Según la documentación de GitHub
Using a token on the command line
Once you have a token, you can enter it instead of your password when performing Git operations over HTTPS.
For example, on the command line you would enter the following:

$ git clone https://github.com/USERNAME/REPO.git
Username: YOUR_USERNAME
Password: YOUR_TOKEN

#8º Añadiremos y configuramos un nuevo remoto:
$ git remote set-url origin https://<Username>:<Token>@github.com/<user>/<repo>.git

$ git remote set-url remote-git-github-2023 https://RenegadeAsturias:<Token>@github.com/RenegadeAsturias/Git-GitHub-2023.git

#9º Ahora ya puedo actualizar mi repositorio remoto de GitHub
$ git push remote-git-github-2023 main
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 372 bytes | 372.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/RenegadeAsturias/Git-GitHub-2023.git
   f783001..a6df762  main -> main
 

.......Continuamos.........

#Para ver nuestra lista de remotos
$ git remote
remote-git-github-2023

#Para subir nuestro repositorio a la nube escribimos
#origin=nombre del remoto y main=nombre de la rama que queremos subir
#en mi ejemplo origin=remote-git-github-2023

$ git push <origin> main

#Y si queremos subir todas las ramas de golpe si tenemos más de una
$ git push <origin> --all

#Para descargar un proyecto de GitHub a nuestro ordenador
$ git clone https://github.com/RenegadeAsturias/Git-GitHub-2023.git

#Hacemos un cambio sobre el repositorio, hacemos un commit y subimos el cambio a GitHub
#utilizando el remoto creado y la rama que queremos subir
$ git push remote-git-github-2023 main

#Para descargarnos los cambios del proyecto de GitHub utlizamos
$ git pull remote-git-github-2023 main


################################################################





